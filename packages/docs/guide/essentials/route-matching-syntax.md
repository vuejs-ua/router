# Синтаксис зіставлення шляхів

<VueSchoolLink
  href="https://vueschool.io/lessons/vue-router-4-advanced-routes-matching-syntax"
  title="Learn how to use advanced route routes' matching syntax"
/>

Більшість застосунків будуть використовувати як статичні шляхи такі як  `/about`, так і динамічні,  на кшталт `/users/:userId`, як ми щойно побачили в [динамічному зіставленні шляхів](./dynamic-matching.md), однак Vue Router може запропонувати набагато більше!

:::tip
Для простішого розуміння, при налаштуванні шляхів **ми пропускаємо властивість `component`** для того, щоб зосередитись на значенні властивості `path`.
:::

## Власні регулярні вирази в параметрах

Вказуючи параметри, наприклад `:userId`, ми цілеспрямовано використовуємо наступний регулярний вираз (regex) `([^/]+)` (принаймні один символ що не є слешем `/`) для того, щоб вилучити параметри з адресного рядку (URL). Таке втілення працюватиме лише в разі, якщо не буде випадку, де потрібно розрізнити два шляхи по вмісту їхніх параметрів. Найпростіший спосіб - додати до шляху статичну секцію, яка дасть змогу розрізнити їх:
```js
const routes = [
  // відповідає /o/3549
  { path: '/o/:orderId' },
  // відповідає /p/books
  { path: '/p/:productName' },
]
```

Але в певних випадках, ми не хочемо додавати цю статичну секцію `/o`/`p`. Однак параметр `orderId` завжди є числом, в той час, як  `productName` може бути будь-чим іншим.
Таким чином в дужках, для параметра можна вказати власний регулярний вираз:

```js
const routes = [
  // /:orderId -> враховує лише числа
  { path: '/:orderId(\\d+)' },
  // /:productName -> враховує все інше
  { path: '/:productName' },
]
```

Тепер, шлях з параметром `/25` відповідатиме параметру `/:orderId`, а всі інші шляхи параметру `/:productName`. Порядок налаштування шляхів не має значення!

:::tip
Переконайтеся що ви екрануєте зворотну риску (слеш) **(`\`)**, як в прикладі вище - `\d` (стає `\\d`), щоб дійсно передати слеш як символ зворотної риски в Javascript рядку.
:::

## Повторювані параметри 

Якщо потрібно, щоб шлях був доступним за адресним рядком з декількома секціями, на кшталт  `/first/second/third`, в такому випадку можна позначити параметр як повторюваний, 
за допомогою символу `*` (0 або більше параметрів) або `+` (1 або більше параметрів):

```js
const routes = [
  // /:chapters -> віпдповідає /one, /one/two, /one/two/three, etc
  { path: '/:chapters+' },
  // /:chapters -> віпдповідає /, /one, /one/two, /one/two/three, etc
  { path: '/:chapters*' },
]
```

Це поверне масив параметрів замість рядків, а також вимагатиме передачі масиву при використанні іменованих маршрутів:

```js
// якщо { path: '/:chapters*', name: 'chapters' },
router.resolve({ name: 'chapters', params: { chapters: [] } }).href
// видасть /
router.resolve({ name: 'chapters', params: { chapters: ['a', 'b'] } }).href
// видасть /a/b

// якщо { path: '/:chapters+', name: 'chapters' },
router.resolve({ name: 'chapters', params: { chapters: [] } }).href
// видасть помилку, оскільки параметр `chapters` - пустий
```

Такі шляхи також можуть включати в себе регулярні вирази (regex), додаючи їх **після закриваючих дужок**:
```js
const routes = [
  // враховує лише числа
  // відповідає /1, /1/2, і т.д.
  { path: '/:chapters(\\d+)+' },
  // відповідає /, /1, /1/2, і т.д
  { path: '/:chapters(\\d+)*' },
]
```

## Строгі та чутливі варіанти шляхів


За замовчуванням, усі шляхи не чутливі до регістру і відповідають шляхам, що мають або не мають похилу риску (slash) в кінці адресного рядку, наприклад `/users` відповідає як `/users`, так і `/users/`, та навіть `/Users`. 
Така поведінка може бути налаштована за допомогою опцій `strict` та `sensitive`, що можуть бути встановлені як на рівні певного шляху, так і на рівні маршрутизатора:

```js
const router = createRouter({
  history: createWebHistory(),
  routes: [
    // відповідатиме /users/posva but not:
    // - /users/posva/ оскільки strict: true
    // - /Users/posva оскільки sensitive: true
    { path: '/users/:id', sensitive: true },
    // відповідатиме /users, /Users, так /users/42, але не /users/ або /users/42/
    { path: '/users/:id?' },
  ],
  strict: true, // застосовується до всіх шляхів
})
```

## Необовʼязкові параметри

За допомогою модифікатора `?` (0 або 1 параметр) можна зазначити вибірковість параметру:

```js
const routes = [
  // відповідатиме /users та /users/posva
  { path: '/users/:userId?' },
  // відповідатиме /users та /users/42
  { path: '/users/:userId(\\d+)?' },
]
```
Зверніть увагу, що `*` також позначає параметр як вибірковий, однак на відміну від `*`, параметр `?` не є повторюваним.

## Виявлення помилок

Якщо потрібно розібратись як шляхи конвертуються в регулярні вирази для того, щоб виявити чому вони не відповідають зазначеним адресним рядкам або для того, щоб повідомити про помилку,  для таких цілей можна використовувати [path ranker tool](https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..#), що дозволяє ділитись шляхами за допомогою адресного рядку (URL).

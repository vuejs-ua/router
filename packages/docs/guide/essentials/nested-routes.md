# Вкладені маршрути

<VueSchoolLink
  href="https://vueschool.io/lessons/nested-routes"
  title="Дізнайтеся про вкладені маршрути"
/>

Інтерфейси деяких додатків складаються з компонентів, які вкладені на декілька рівнів у глибину. У цьому випадку дуже часто сегменти URL-адреси відповідають, наприклад, певній структурі вкладених компонентів:

```
/user/johnny/profile                     /user/johnny/posts
+------------------+                  +-----------------+
| Користувач       |                  | Користувач      |
| +--------------+ |                  | +-------------+ |
| | Профіль      | |  +------------>  | | Пости       | |
| |              | |                  | |             | |
| +--------------+ |                  | +-------------+ |
+------------------+                  +-----------------+
```

За допомогою Vue Router ви можете передати цей зв'язок за допомогою конфігурації вкладених маршрутів.

Враховуючи додаток, який ми створили в попередньому розділі:

```html
<div id="app">
  <router-view></router-view>
</div>
```

```js
const User = {
  template: '<div>User {{ $route.params.id }}</div>',
}

// вони передаються в `createRouter`
const routes = [{ path: '/user/:id', component: User }]
```

Тут `<router-view>` - це `<router-view>` верхнього рівня. Він рендерить компонент, якому відповідає маршрут верхнього рівня. Аналогічно, відрендерений компонент може також містити власний, вкладений `<router-view>`. Наприклад, якщо ми додамо його у шаблон компонента `User`:

```js
const User = {
  template: `
    <div class="user">
      <h2>User {{ $route.params.id }}</h2>
      <router-view></router-view>
    </div>
  `,
}
```

Щоб відрендерити компоненти у цьому вкладеному `router-view`, нам потрібно використати опцію `children` у будь-якому з маршрутів:

```js
const routes = [
  {
    path: '/user/:id',
    component: User,
    children: [
      {
        // UserProfile буде відрендерено всередині <router-view> користувача,
        // коли /user/:id/profile співпадає
        path: 'profile',
        component: UserProfile,
      },
      {
        // UserPosts буде відрендерено всередині <router-view> користувача,
        // коли /user/:id/posts співпадає
        path: 'posts',
        component: UserPosts,
      },
    ],
  },
]
```

**Зверніть увагу, що вкладені шляхи, які починаються з `/`, вважатимуться кореневими. Це дозволяє використовувати вкладеність компонентів без необхідності використання вкладеної URL-адреси.**

Як ви можете бачити, опція `children` - це просто ще один масив маршрутів, як і сам `routes`. Таким чином, ви можете створювати стільки вкладених виглядів, скільки вам потрібно.

Наразі, при наведеній вище конфігурації, коли ви відвідаєте `/user/eduardo`, у `router-view` користувача `User` нічого не буде показано, оскільки не знайдено жодного вкладеного маршруту. Можливо, ви хочете щось там відрендерити. У такому випадку ви можете вказати порожній вкладений шлях:

```js
const routes = [
  {
    path: '/user/:id',
    component: User,
    children: [
      // UserHome буде відображено всередині <router-view> користувача,
      // коли /user/:id співпадає
      { path: '', component: UserHome },

      // ...інші субмаршрути
    ],
  },
]
```

Демо-версію цього прикладу можна знайти [тут](https://codesandbox.io/s/nested-views-vue-router-4-examples-hl326?initialpath=%2Fusers%2Feduardo).

## Nested Named Routes

При роботі з [іменованими маршрутами](./named-routes.md) ви зазвичай **іменуєте дочірні маршрути**:

```js
const routes = [
  {
    path: '/user/:id',
    component: User,
    // зверніть увагу, що тільки дочірній маршрут має назву
    children: [{ path: '', name: 'user', component: UserHome }],
  },
]
```

Це гарантує, що при переході до `/user/:id` завжди відображатиметься вкладений маршрут.

У деяких сценаріях вам може знадобитися перехід до іменованого маршруту без переходу до вкладеного маршруту. Наприклад, якщо ви хочете перейти до `/user/:id` без відображення вкладеного маршруту. У цьому випадку ви можете **також** назвати батьківський маршрут, але зауважте, що **при перезавантаженні сторінки завжди буде показано вкладений дочірній маршрут**, оскільки це вважатиметься переходом до шляху `/users/:id`, а не до названого маршруту:

```js
const routes = [
  {
    path: '/user/:id',
    name: 'user-parent',
    component: User,
    children: [{ path: '', name: 'user', component: UserHome }],
  },
]
```
